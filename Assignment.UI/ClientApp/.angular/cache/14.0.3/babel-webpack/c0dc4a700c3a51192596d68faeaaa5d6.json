{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = require('../util/root');\n\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AsyncAction = function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.pending = false;\n    this.work = work;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    } // Always replace the current state with the new state.\n\n\n    this.state = state; // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n\n    this.pending = true;\n    var id = this.id;\n    var scheduler = this.scheduler; //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay; // If this action has already an async Id, don't request a new one.\n\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If this action is rescheduled with the same delay time, don't clear the interval id.\n\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    } // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n\n\n    return root_1.root.clearInterval(id) && undefined || undefined;\n  };\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action_1.Action);\n\nexports.AsyncAction = AsyncAction;","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","root_1","require","Action_1","AsyncAction","_super","scheduler","work","call","pending","schedule","state","delay","closed","id","recycleAsyncId","requestAsyncId","root","setInterval","flush","bind","clearInterval","undefined","execute","Error","error","_execute","errored","errorValue","e","unsubscribe","_unsubscribe","actions","index","indexOf","splice","Action","exports"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/scheduler/AsyncAction.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.pending = false;\n        this.work = work;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    /** @deprecated internal use only */ AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
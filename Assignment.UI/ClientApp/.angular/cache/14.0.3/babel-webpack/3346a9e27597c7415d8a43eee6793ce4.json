{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\n\n\nfunction exhaustMap(project, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  };\n}\n\nexports.exhaustMap = exhaustMap;\n\nvar SwitchFirstMapOperator = function () {\n  function SwitchFirstMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n\n  return SwitchFirstMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchFirstMapSubscriber = function (_super) {\n  __extends(SwitchFirstMapSubscriber, _super);\n\n  function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.hasSubscription = false;\n    this.hasCompleted = false;\n    this.index = 0;\n  }\n\n  SwitchFirstMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    try {\n      var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","OuterSubscriber_1","require","subscribeToResult_1","exhaustMap","project","resultSelector","source","lift","SwitchFirstMapOperator","exports","call","subscriber","subscribe","SwitchFirstMapSubscriber","_super","destination","hasSubscription","hasCompleted","index","_next","value","tryNext","result","add","subscribeToResult","err","error","_complete","complete","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","_a","trySelectResult","next","notifyError","notifyComplete","remove","OuterSubscriber"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/operators/exhaustMap.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
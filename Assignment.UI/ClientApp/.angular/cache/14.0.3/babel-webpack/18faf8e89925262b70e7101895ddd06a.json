{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar isFunction_1 = require('../util/isFunction');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar Subscription_1 = require('../Subscription');\n\nvar toString = Object.prototype.toString;\n\nfunction isNodeStyleEventEmitter(sourceObj) {\n  return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj) {\n  return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isNodeList(sourceObj) {\n  return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\n\nfunction isHTMLCollection(sourceObj) {\n  return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\n\nfunction isEventTarget(sourceObj) {\n  return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromEventObservable = function (_super) {\n  __extends(FromEventObservable, _super);\n\n  function FromEventObservable(sourceObj, eventName, selector, options) {\n    _super.call(this);\n\n    this.sourceObj = sourceObj;\n    this.eventName = eventName;\n    this.selector = selector;\n    this.options = options;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Creates an Observable that emits events of a specific type coming from the\n   * given event target.\n   *\n   * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n   * EventEmitter events or others.</span>\n   *\n   * <img src=\"./img/fromEvent.png\" width=\"100%\">\n   *\n   * `fromEvent` accepts as a first argument event target, which is an object with methods\n   * for registering event handler functions. As a second argument it takes string that indicates\n   * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n   * which are described in detail below. If your event target does not match any of the ones listed,\n   * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n   * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n   * handler functions have different names, but they all accept a string describing event type\n   * and function itself, which will be called whenever said event happens.\n   *\n   * Every time resulting Observable is subscribed, event handler function will be registered\n   * to event target on given event type. When that event fires, value\n   * passed as a first argument to registered function will be emitted by output Observable.\n   * When Observable is unsubscribed, function will be unregistered from event target.\n   *\n   * Note that if event target calls registered function with more than one argument, second\n   * and following arguments will not appear in resulting stream. In order to get access to them,\n   * you can pass to `fromEvent` optional project function, which will be called with all arguments\n   * passed to event handler. Output Observable will then emit value returned by project function,\n   * instead of the usual value.\n   *\n   * Remember that event targets listed below are checked via duck typing. It means that\n   * no matter what kind of object you have and no matter what environment you work in,\n   * you can safely use `fromEvent` on that object if it exposes described methods (provided\n   * of course they behave as was described above). So for example if Node.js library exposes\n   * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n   * a good choice.\n   *\n   * If the API you use is more callback then event handler oriented (subscribed\n   * callback function fires only once and thus there is no need to manually\n   * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n   * instead.\n   *\n   * `fromEvent` supports following types of event targets:\n   *\n   * **DOM EventTarget**\n   *\n   * This is an object with `addEventListener` and `removeEventListener` methods.\n   *\n   * In the browser, `addEventListener` accepts - apart from event type string and event\n   * handler function arguments - optional third parameter, which is either an object or boolean,\n   * both used for additional configuration how and when passed function will be called. When\n   * `fromEvent` is used with event target of that type, you can provide this values\n   * as third parameter as well.\n   *\n   * **Node.js EventEmitter**\n   *\n   * An object with `addListener` and `removeListener` methods.\n   *\n   * **JQuery-style event target**\n   *\n   * An object with `on` and `off` methods\n   *\n   * **DOM NodeList**\n   *\n   * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n   *\n   * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n   * it contains and install event handler function in every of them. When returned Observable\n   * is unsubscribed, function will be removed from all Nodes.\n   *\n   * **DOM HtmlCollection**\n   *\n   * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n   * installed and removed in each of elements.\n   *\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * var clicks = Rx.Observable.fromEvent(document, 'click');\n   * clicks.subscribe(x => console.log(x));\n   *\n   * // Results in:\n   * // MouseEvent object logged to console every time a click\n   * // occurs on the document.\n   *\n   *\n   * @example <caption>Use addEventListener with capture option</caption>\n   * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n   *                                                                          // which will be passed to addEventListener\n   * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n   *\n   * clicksInDocument.subscribe(() => console.log('document'));\n   * clicksInDiv.subscribe(() => console.log('div'));\n   *\n   * // By default events bubble UP in DOM tree, so normally\n   * // when we would click on div in document\n   * // \"div\" would be logged first and then \"document\".\n   * // Since we specified optional `capture` option, document\n   * // will catch event when it goes DOWN DOM tree, so console\n   * // will log \"document\" and then \"div\".\n   *\n   * @see {@link bindCallback}\n   * @see {@link bindNodeCallback}\n   * @see {@link fromEventPattern}\n   *\n   * @param {EventTargetLike} target The DOM EventTarget, Node.js\n   * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n   * @param {string} eventName The event name of interest, being emitted by the\n   * `target`.\n   * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n   * @param {SelectorMethodSignature<T>} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEvent\n   * @owner Observable\n   */\n\n\n  FromEventObservable.create = function (target, eventName, options, selector) {\n    if (isFunction_1.isFunction(options)) {\n      selector = options;\n      options = undefined;\n    }\n\n    return new FromEventObservable(target, eventName, selector, options);\n  };\n\n  FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n    var unsubscribe;\n\n    if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n      for (var i = 0, len = sourceObj.length; i < len; i++) {\n        FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n      }\n    } else if (isEventTarget(sourceObj)) {\n      var source_1 = sourceObj;\n      sourceObj.addEventListener(eventName, handler, options);\n\n      unsubscribe = function () {\n        return source_1.removeEventListener(eventName, handler, options);\n      };\n    } else if (isJQueryStyleEventEmitter(sourceObj)) {\n      var source_2 = sourceObj;\n      sourceObj.on(eventName, handler);\n\n      unsubscribe = function () {\n        return source_2.off(eventName, handler);\n      };\n    } else if (isNodeStyleEventEmitter(sourceObj)) {\n      var source_3 = sourceObj;\n      sourceObj.addListener(eventName, handler);\n\n      unsubscribe = function () {\n        return source_3.removeListener(eventName, handler);\n      };\n    } else {\n      throw new TypeError('Invalid event target');\n    }\n\n    subscriber.add(new Subscription_1.Subscription(unsubscribe));\n  };\n  /** @deprecated internal use only */\n\n\n  FromEventObservable.prototype._subscribe = function (subscriber) {\n    var sourceObj = this.sourceObj;\n    var eventName = this.eventName;\n    var options = this.options;\n    var selector = this.selector;\n    var handler = selector ? function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n\n      if (result === errorObject_1.errorObject) {\n        subscriber.error(errorObject_1.errorObject.e);\n      } else {\n        subscriber.next(result);\n      }\n    } : function (e) {\n      return subscriber.next(e);\n    };\n    FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n  };\n\n  return FromEventObservable;\n}(Observable_1.Observable);\n\nexports.FromEventObservable = FromEventObservable;","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Observable_1","require","tryCatch_1","isFunction_1","errorObject_1","Subscription_1","toString","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","call","isHTMLCollection","isEventTarget","addEventListener","removeEventListener","FromEventObservable","_super","eventName","selector","options","target","isFunction","undefined","setupSubscription","handler","subscriber","unsubscribe","i","len","length","source_1","source_2","source_3","TypeError","add","Subscription","_subscribe","args","_i","arguments","result","tryCatch","apply","errorObject","error","e","next","Observable","exports"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/observable/FromEventObservable.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    /** @deprecated internal use only */ FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;EACxD,KAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;EAC1C,SAASE,EAAT,GAAc;IAAE,KAAKC,WAAL,GAAmBL,CAAnB;EAAuB;;EACvCA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaM,MAAM,CAACC,MAAP,CAAcP,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,CAJD;;AAKA,IAAIK,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAAxB;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,oBAAD,CAA1B;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,qBAAD,CAA3B;;AACA,IAAII,cAAc,GAAGJ,OAAO,CAAC,iBAAD,CAA5B;;AACA,IAAIK,QAAQ,GAAGR,MAAM,CAACD,SAAP,CAAiBS,QAAhC;;AACA,SAASC,uBAAT,CAAiCC,SAAjC,EAA4C;EACxC,OAAO,CAAC,CAACA,SAAF,IAAe,OAAOA,SAAS,CAACC,WAAjB,KAAiC,UAAhD,IAA8D,OAAOD,SAAS,CAACE,cAAjB,KAAoC,UAAzG;AACH;;AACD,SAASC,yBAAT,CAAmCH,SAAnC,EAA8C;EAC1C,OAAO,CAAC,CAACA,SAAF,IAAe,OAAOA,SAAS,CAACI,EAAjB,KAAwB,UAAvC,IAAqD,OAAOJ,SAAS,CAACK,GAAjB,KAAyB,UAArF;AACH;;AACD,SAASC,UAAT,CAAoBN,SAApB,EAA+B;EAC3B,OAAO,CAAC,CAACA,SAAF,IAAeF,QAAQ,CAACS,IAAT,CAAcP,SAAd,MAA6B,mBAAnD;AACH;;AACD,SAASQ,gBAAT,CAA0BR,SAA1B,EAAqC;EACjC,OAAO,CAAC,CAACA,SAAF,IAAeF,QAAQ,CAACS,IAAT,CAAcP,SAAd,MAA6B,yBAAnD;AACH;;AACD,SAASS,aAAT,CAAuBT,SAAvB,EAAkC;EAC9B,OAAO,CAAC,CAACA,SAAF,IAAe,OAAOA,SAAS,CAACU,gBAAjB,KAAsC,UAArD,IAAmE,OAAOV,SAAS,CAACW,mBAAjB,KAAyC,UAAnH;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,IAAIC,mBAAmB,GAAI,UAAUC,MAAV,EAAkB;EACzC/B,SAAS,CAAC8B,mBAAD,EAAsBC,MAAtB,CAAT;;EACA,SAASD,mBAAT,CAA6BZ,SAA7B,EAAwCc,SAAxC,EAAmDC,QAAnD,EAA6DC,OAA7D,EAAsE;IAClEH,MAAM,CAACN,IAAP,CAAY,IAAZ;;IACA,KAAKP,SAAL,GAAiBA,SAAjB;IACA,KAAKc,SAAL,GAAiBA,SAAjB;IACA,KAAKC,QAAL,GAAgBA,QAAhB;IACA,KAAKC,OAAL,GAAeA,OAAf;EACH;EACD;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIJ,mBAAmB,CAACrB,MAApB,GAA6B,UAAU0B,MAAV,EAAkBH,SAAlB,EAA6BE,OAA7B,EAAsCD,QAA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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar isArray_1 = require('../util/isArray');\n\nvar race_1 = require('../observable/race');\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\n\n\nfunction race() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function raceOperatorFunction(source) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n      observables = observables[0];\n    }\n\n    return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.race = race;","map":{"version":3,"names":["isArray_1","require","race_1","race","observables","_i","arguments","length","raceOperatorFunction","source","isArray","lift","call","apply","concat","exports"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/operators/race.js"],"sourcesContent":["\"use strict\";\nvar isArray_1 = require('../util/isArray');\nvar race_1 = require('../observable/race');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        // if the only argument is an array, it was most likely called with\n        // `pair([obs1, obs2, ...])`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.race = race;\n"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,oBAAD,CAApB;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,IAAT,GAAgB;EACZ,IAAIC,WAAW,GAAG,EAAlB;;EACA,KAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;IAC1CD,WAAW,CAACC,EAAE,GAAG,CAAN,CAAX,GAAsBC,SAAS,CAACD,EAAD,CAA/B;EACH;;EACD,OAAO,SAASG,oBAAT,CAA8BC,MAA9B,EAAsC;IACzC;IACA;IACA,IAAIL,WAAW,CAACG,MAAZ,KAAuB,CAAvB,IAA4BP,SAAS,CAACU,OAAV,CAAkBN,WAAW,CAAC,CAAD,CAA7B,CAAhC,EAAmE;MAC/DA,WAAW,GAAGA,WAAW,CAAC,CAAD,CAAzB;IACH;;IACD,OAAOK,MAAM,CAACE,IAAP,CAAYC,IAAZ,CAAiBV,MAAM,CAACC,IAAP,CAAYU,KAAZ,CAAkB,KAAK,CAAvB,EAA0B,CAACJ,MAAD,EAASK,MAAT,CAAgBV,WAAhB,CAA1B,CAAjB,CAAP;EACH,CAPD;AAQH;;AACDW,OAAO,CAACZ,IAAR,GAAeA,IAAf"},"metadata":{},"sourceType":"script"}
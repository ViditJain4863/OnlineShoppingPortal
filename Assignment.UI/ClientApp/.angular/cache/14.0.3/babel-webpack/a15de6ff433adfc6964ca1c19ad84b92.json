{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\n\n\nfunction tap(nextOrObserver, error, complete) {\n  return function tapOperatorFunction(source) {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nexports.tap = tap;\n\nvar DoOperator = function () {\n  function DoOperator(nextOrObserver, error, complete) {\n    this.nextOrObserver = nextOrObserver;\n    this.error = error;\n    this.complete = complete;\n  }\n\n  DoOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  };\n\n  return DoOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DoSubscriber = function (_super) {\n  __extends(DoSubscriber, _super);\n\n  function DoSubscriber(destination, nextOrObserver, error, complete) {\n    _super.call(this, destination);\n\n    var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    safeSubscriber.syncErrorThrowable = true;\n    this.add(safeSubscriber);\n    this.safeSubscriber = safeSubscriber;\n  }\n\n  DoSubscriber.prototype._next = function (value) {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.next(value);\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.next(value);\n    }\n  };\n\n  DoSubscriber.prototype._error = function (err) {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.error(err);\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.error(err);\n    }\n  };\n\n  DoSubscriber.prototype._complete = function () {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.complete();\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  return DoSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Subscriber_1","require","tap","nextOrObserver","error","complete","tapOperatorFunction","source","lift","DoOperator","exports","call","subscriber","subscribe","DoSubscriber","_super","destination","safeSubscriber","Subscriber","syncErrorThrowable","add","_next","value","next","syncErrorThrown","syncErrorValue","_error","err","_complete"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/operators/tap.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
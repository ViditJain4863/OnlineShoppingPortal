{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\n\n\nfunction expand(project, concurrent, scheduler) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (scheduler === void 0) {\n    scheduler = undefined;\n  }\n\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return function (source) {\n    return source.lift(new ExpandOperator(project, concurrent, scheduler));\n  };\n}\n\nexports.expand = expand;\n\nvar ExpandOperator = function () {\n  function ExpandOperator(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  ExpandOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  };\n\n  return ExpandOperator;\n}();\n\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ExpandSubscriber = function (_super) {\n  __extends(ExpandSubscriber, _super);\n\n  function ExpandSubscriber(destination, project, concurrent, scheduler) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  ExpandSubscriber.dispatch = function (arg) {\n    var subscriber = arg.subscriber,\n        result = arg.result,\n        value = arg.value,\n        index = arg.index;\n    subscriber.subscribeToProjection(result, value, index);\n  };\n\n  ExpandSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    var index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      var result = tryCatch_1.tryCatch(this.project)(value, index);\n\n      if (result === errorObject_1.errorObject) {\n        destination.error(errorObject_1.errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        var state = {\n          subscriber: this,\n          result: result,\n          value: value,\n          index: index\n        };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n    this.active++;\n    this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n  };\n\n  ExpandSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._next(innerValue);\n  };\n\n  ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.ExpandSubscriber = ExpandSubscriber;","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","tryCatch_1","require","errorObject_1","OuterSubscriber_1","subscribeToResult_1","expand","project","concurrent","scheduler","Number","POSITIVE_INFINITY","undefined","source","lift","ExpandOperator","exports","call","subscriber","subscribe","ExpandSubscriber","_super","destination","index","active","hasCompleted","buffer","dispatch","arg","result","value","subscribeToProjection","_next","closed","_complete","next","tryCatch","errorObject","error","e","state","add","schedule","push","subscribeToResult","complete","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyComplete","remove","length","shift","OuterSubscriber"],"sources":["C:/Users/vidit.jain/node_modules/rxjs/operators/expand.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;EACxD,KAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;EAC1C,SAASE,EAAT,GAAc;IAAE,KAAKC,WAAL,GAAmBL,CAAnB;EAAuB;;EACvCA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaM,MAAM,CAACC,MAAP,CAAcP,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,CAJD;;AAKA,IAAIK,UAAU,GAAGC,OAAO,CAAC,kBAAD,CAAxB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,qBAAD,CAA3B;;AACA,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,oBAAD,CAA/B;;AACA,IAAIG,mBAAmB,GAAGH,OAAO,CAAC,2BAAD,CAAjC;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,MAAT,CAAgBC,OAAhB,EAAyBC,UAAzB,EAAqCC,SAArC,EAAgD;EAC5C,IAAID,UAAU,KAAK,KAAK,CAAxB,EAA2B;IAAEA,UAAU,GAAGE,MAAM,CAACC,iBAApB;EAAwC;;EACrE,IAAIF,SAAS,KAAK,KAAK,CAAvB,EAA0B;IAAEA,SAAS,GAAGG,SAAZ;EAAwB;;EACpDJ,UAAU,GAAG,CAACA,UAAU,IAAI,CAAf,IAAoB,CAApB,GAAwBE,MAAM,CAACC,iBAA/B,GAAmDH,UAAhE;EACA,OAAO,UAAUK,MAAV,EAAkB;IAAE,OAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,cAAJ,CAAmBR,OAAnB,EAA4BC,UAA5B,EAAwCC,SAAxC,CAAZ,CAAP;EAAyE,CAApG;AACH;;AACDO,OAAO,CAACV,MAAR,GAAiBA,MAAjB;;AACA,IAAIS,cAAc,GAAI,YAAY;EAC9B,SAASA,cAAT,CAAwBR,OAAxB,EAAiCC,UAAjC,EAA6CC,SAA7C,EAAwD;IACpD,KAAKF,OAAL,GAAeA,OAAf;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;EACH;;EACDM,cAAc,CAACjB,SAAf,CAAyBmB,IAAzB,GAAgC,UAAUC,UAAV,EAAsBL,MAAtB,EAA8B;IAC1D,OAAOA,MAAM,CAACM,SAAP,CAAiB,IAAIC,gBAAJ,CAAqBF,UAArB,EAAiC,KAAKX,OAAtC,EAA+C,KAAKC,UAApD,EAAgE,KAAKC,SAArE,CAAjB,CAAP;EACH,CAFD;;EAGA,OAAOM,cAAP;AACH,CAVqB,EAAtB;;AAWAC,OAAO,CAACD,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIK,gBAAgB,GAAI,UAAUC,MAAV,EAAkB;EACtC9B,SAAS,CAAC6B,gBAAD,EAAmBC,MAAnB,CAAT;;EACA,SAASD,gBAAT,CAA0BE,WAA1B,EAAuCf,OAAvC,EAAgDC,UAAhD,EAA4DC,SAA5D,EAAuE;IACnEY,MAAM,CAACJ,IAAP,CAAY,IAAZ,EAAkBK,WAAlB;;IACA,KAAKf,OAAL,GAAeA,OAAf;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKc,KAAL,GAAa,CAAb;IACA,KAAKC,MAAL,GAAc,CAAd;IACA,KAAKC,YAAL,GAAoB,KAApB;;IACA,IAAIjB,UAAU,GAAGE,MAAM,CAACC,iBAAxB,EAA2C;MACvC,KAAKe,MAAL,GAAc,EAAd;IACH;EACJ;;EACDN,gBAAgB,CAACO,QAAjB,GAA4B,UAAUC,GAAV,EAAe;IACvC,IAAIV,UAAU,GAAGU,GAAG,CAACV,UAArB;IAAA,IAAiCW,MAAM,GAAGD,GAAG,CAACC,MAA9C;IAAA,IAAsDC,KAAK,GAAGF,GAAG,CAACE,KAAlE;IAAA,IAAyEP,KAAK,GAAGK,GAAG,CAACL,KAArF;IACAL,UAAU,CAACa,qBAAX,CAAiCF,MAAjC,EAAyCC,KAAzC,EAAgDP,KAAhD;EACH,CAHD;;EAIAH,gBAAgB,CAACtB,SAAjB,CAA2BkC,KAA3B,GAAmC,UAAUF,KAAV,EAAiB;IAChD,IAAIR,WAAW,GAAG,KAAKA,WAAvB;;IACA,IAAIA,WAAW,CAACW,MAAhB,EAAwB;MACpB,KAAKC,SAAL;;MACA;IACH;;IACD,IAAIX,KAAK,GAAG,KAAKA,KAAL,EAAZ;;IACA,IAAI,KAAKC,MAAL,GAAc,KAAKhB,UAAvB,EAAmC;MAC/Bc,WAAW,CAACa,IAAZ,CAAiBL,KAAjB;MACA,IAAID,MAAM,GAAG5B,UAAU,CAACmC,QAAX,CAAoB,KAAK7B,OAAzB,EAAkCuB,KAAlC,EAAyCP,KAAzC,CAAb;;MACA,IAAIM,MAAM,KAAK1B,aAAa,CAACkC,WAA7B,EAA0C;QACtCf,WAAW,CAACgB,KAAZ,CAAkBnC,aAAa,CAACkC,WAAd,CAA0BE,CAA5C;MACH,CAFD,MAGK,IAAI,CAAC,KAAK9B,SAAV,EAAqB;QACtB,KAAKsB,qBAAL,CAA2BF,MAA3B,EAAmCC,KAAnC,EAA0CP,KAA1C;MACH,CAFI,MAGA;QACD,IAAIiB,KAAK,GAAG;UAAEtB,UAAU,EAAE,IAAd;UAAoBW,MAAM,EAAEA,MAA5B;UAAoCC,KAAK,EAAEA,KAA3C;UAAkDP,KAAK,EAAEA;QAAzD,CAAZ;QACA,KAAKkB,GAAL,CAAS,KAAKhC,SAAL,CAAeiC,QAAf,CAAwBtB,gBAAgB,CAACO,QAAzC,EAAmD,CAAnD,EAAsDa,KAAtD,CAAT;MACH;IACJ,CAbD,MAcK;MACD,KAAKd,MAAL,CAAYiB,IAAZ,CAAiBb,KAAjB;IACH;EACJ,CAxBD;;EAyBAV,gBAAgB,CAACtB,SAAjB,CAA2BiC,qBAA3B,GAAmD,UAAUF,MAAV,EAAkBC,KAAlB,EAAyBP,KAAzB,EAAgC;IAC/E,KAAKC,MAAL;IACA,KAAKiB,GAAL,CAASpC,mBAAmB,CAACuC,iBAApB,CAAsC,IAAtC,EAA4Cf,MAA5C,EAAoDC,KAApD,EAA2DP,KAA3D,CAAT;EACH,CAHD;;EAIAH,gBAAgB,CAACtB,SAAjB,CAA2BoC,SAA3B,GAAuC,YAAY;IAC/C,KAAKT,YAAL,GAAoB,IAApB;;IACA,IAAI,KAAKA,YAAL,IAAqB,KAAKD,MAAL,KAAgB,CAAzC,EAA4C;MACxC,KAAKF,WAAL,CAAiBuB,QAAjB;IACH;EACJ,CALD;;EAMAzB,gBAAgB,CAACtB,SAAjB,CAA2BgD,UAA3B,GAAwC,UAAUC,UAAV,EAAsBC,UAAtB,EAAkCC,UAAlC,EAA8CC,UAA9C,EAA0DC,QAA1D,EAAoE;IACxG,KAAKnB,KAAL,CAAWgB,UAAX;EACH,CAFD;;EAGA5B,gBAAgB,CAACtB,SAAjB,CAA2BsD,cAA3B,GAA4C,UAAUD,QAAV,EAAoB;IAC5D,IAAIzB,MAAM,GAAG,KAAKA,MAAlB;IACA,KAAK2B,MAAL,CAAYF,QAAZ;IACA,KAAK3B,MAAL;;IACA,IAAIE,MAAM,IAAIA,MAAM,CAAC4B,MAAP,GAAgB,CAA9B,EAAiC;MAC7B,KAAKtB,KAAL,CAAWN,MAAM,CAAC6B,KAAP,EAAX;IACH;;IACD,IAAI,KAAK9B,YAAL,IAAqB,KAAKD,MAAL,KAAgB,CAAzC,EAA4C;MACxC,KAAKF,WAAL,CAAiBuB,QAAjB;IACH;EACJ,CAVD;;EAWA,OAAOzB,gBAAP;AACH,CApEuB,CAoEtBhB,iBAAiB,CAACoD,eApEI,CAAxB;;AAqEAxC,OAAO,CAACI,gBAAR,GAA2BA,gBAA3B"},"metadata":{},"sourceType":"script"}